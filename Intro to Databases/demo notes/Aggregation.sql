# aggregation functions appeared in SELECT clause
# two new clause: GROUPBY and HAVING
# GROUPBY partition relations into group and use aggregation function on the groups
# HAVING test filters on the results of aggregate values,
# WHERE applies to single row at a time but HAVING will apply to the groups generated by GROUPBY

# select average GPA
select avg(GPA)
from Student;

select min(GPA)
from Student, Apply
where Student.sID = Apply.sID and major = 'CS';

# 计算申请CS的平均GPA
select avg(GPA)
from Student, Apply
where Student.sID = Apply.sID and major = 'CS';		
# 但这个结果并不正确， 因为通过select * from 可以看到，有的同学申请了多个学校的CS， 直接使用avg会重复计算
# 正确的方法是每个学生无论申请多少个学校，其GPA只计算一次

# 解决方法， 使用subquery
select avg(GPA)
from Student
where sID in (select sID from Apply where major = 'CS');	

# count function
# num of colleges bigger than 15000
select count(*)
from College
where enrollment > 15000;

# counting the num of students applying to Cornell
select count(*)
from Apply
where cName = 'Cornell'; # 但是！！ 这里计算的是cornell收到的申请数，并不是申请学生人数

select count(distinct(sID)) # distinct 放到count中， count（distinct（））
from Apply
where cName = 'Cornell'; 

# students such that number of other student with same GPA is
# equal to number of other students with same sizeHS
select *
from Student s1
where (select count(*) from Student s2
		where s2.sID <> s1.sID and s2.GPA = s1.GPA) = # other student, 因为加入了id不相同的条件
        (select count(*) from Student s2
        where s2.sID <> s1.sID and s2.sizeHS = s1.sizeHS);

# computes the amount by which the average GPA of studentswho apply to CS 
# exceeds the average GPA of students who don't apply to CS
select CS.avgGPA - nonCS.avgGPA
from (select avg(GPA) as avgGPA from Student
		where sID in (
			select sID from Apply where major = 'CS')) as CS,
		(select avg(GPA) as avgGPA from Student
        where sID not in (
			select sID from Apply where major = 'CS')) as nonCS;



select distinct (select avg(GPA) as avgGPA from Student		# 不加distinct的话会对student中每一个tuple都计算一次
		where sID in (
			select sID from Apply where major = 'CS')) -
		(select avg(GPA) as avgGPA from Student
        where sID not in (
			select sID from Apply where major = 'CS')) as d
from Student;

# Groupby 

# number of applications to each college
select *
from Apply
order by cName;

select cName, count(*)
from Apply
group by cName;

# college enrollment by state
select state, sum(enrollment)
from College
group by state;


# min and max GPAs of applicants to each college and major
select cName, major, min(GPA), max(GPA)
from Student, Apply
where Student.sID = Apply.sID
group by cName, major;

# spread between max and min
select max(mx - mn)
from (select cName, major, min(GPA) as mn, max(GPA) as mx
from Student, Apply
where Student.sID = Apply.sID
group by cName, major) M;

# number of colleges applied to by each student
select Student.sID, cName
from Student, Apply
where Student.sID = Apply.sID
order by Student.sID;

select Student.sID, count(distinct cName)
from Student, Apply
where Student.sID = Apply.sID
group by Student.sID;


# include students who haven't anywhere at all
select Student.sID, count(distinct cName)
from Student, Apply
where Student.sID = Apply.sID
group by Student.sID
union
select sID, 0
from Student
where sID not in (select sID from Apply);


# HAVING
# apply after GROUPBY clause to check the status involving the entire group
select cName
from Apply
group by cName
having count(*) < 5;	# 只保留APPLICATION数小于5的college

# 不用groupby 和 having 来达到相同目的
select distinct cName
from Apply a1
where 5 > (select count(*) from Apply a2 where a2.cName = a1.cName);

# Colleges with fewer than 5 APPLICANTS
select cName
from Apply
group by cName
having count(distinct sID) < 5;


# majors whose applicant's GPA is below the average
select major
from Student, Apply
where Student.sID = Apply.sID
group by major
having max(GPA) < (select avg(GPA) from Student);




